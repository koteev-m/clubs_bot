# P2.4 Discovery: текущие Telegram-флоу и минимальные fallback-сценарии без miniapp

## 1) Что реально подключено в production webhook сейчас

По `Application.kt` в webhook-роутер подключены только два Telegram-обработчика:
- `InvitationTelegramHandler`;
- `SupportTelegramHandler`.

`TelegramCallbackRouter` маршрутизирует апдейты только в эти обработчики:
- callback `support:rate:*` → support;
- callback `inv_confirm:*` / `inv_decline:*` и апдейты без callback → invitation.

Следствие: бот сейчас устойчиво покрывает только сценарии приглашений (`/start inv_*`) и оценку уже закрытого тикета поддержки через inline-кнопки.

## 2) Что есть в коде, но сейчас не используется (мертвые/недоведённые user-flows)

В кодовой базе есть заготовки полноценных гостевых меню (`Keyboards`, `MenuCallbacksHandler`, `GuestFlowHandler`), включая:
- `menu:clubs`, `menu:bookings`;
- выдачу клубов/ночей/столов;
- просмотр и отмену «моих броней».

Но в `Application.kt` эти хендлеры не инстанцируются и не подключены к webhook-роутингу. Дополнительно `Keyboards.startMenu` содержит кнопки `menu:ask` и `menu:music`, а `MenuCallbacksHandler` не роутит их — даже при подключении будет функциональный разрыв.

## 3) Где miniapp сейчас является hard dependency

### 3.1 Получить QR пропуск на ночь

`/api/me/bookings` и `/api/bookings/{id}/qr` находятся под `withMiniAppAuth` (initData), и отдают данные только после miniapp-аутентификации.

Это означает: в Telegram-боте без miniapp сейчас нет «легального» пути получить QR по команде/кнопке.

### 3.2 Посмотреть ближайшую бронь/приглашения

- Ближайшие брони: API «моих броней» также закрыто miniapp-auth.
- Приглашения: работают через deep-link `/start inv_<token>` и inline callback confirm/decline, т.е. этот кусок уже miniapp-независим.

### 3.3 Задать вопрос клубу

`/api/support/*` также требует `withMiniAppAuth`, поэтому создание тикета из чистого Telegram-чата сейчас отсутствует.

Есть только callback-оценка ответа (`support:rate:*`) — это финальный шаг уже существующего тикета, не создание нового обращения.

## 4) Минимальные fallback-цели (чтобы пользователь «дошёл до цели» без miniapp)

Ниже — минимальный набор, который можно внедрить без полного восстановления legacy-меню.

### Fallback A: QR пропуск на ночь

**UX-команда:** `/qr` (или кнопка «Мой QR на сегодня»).

**Минимальная реализация:**
1. Идентифицировать пользователя по `telegram_user_id` (по `from.id`) через `UserRepository`.
2. Взять ближайшую активную бронь пользователя (`BOOKED`, окно не закончилось) из `BookingState`.
3. Сгенерировать payload тем же `QrBookingCodec`, что использует `/api/bookings/{id}/qr`.
4. Отправить payload как текст + предупреждение о сроке актуальности; опционально добавить Telegram QR-картинку.

**Почему минимально:** не требует miniapp initData и не трогает фронт.

### Fallback B: Ближайшая бронь/приглашения

**UX-команды:**
- `/my` — ближайшая бронь (клуб, окно прибытия, стол, статус);
- `/invites` — активные приглашения (или подсказка по deep-link).

**Минимальная реализация:**
1. Для `/my` использовать тот же источник, что `me/bookings` (через доменный слой `BookingState`), но авторизацию делать по Telegram user id.
2. Для `/invites` оставить существующий flow `/start inv_*` как основной, а команду использовать как discoverability-слой: показать «Как принять инвайт» + последние активные инвайты (если доступны через `InvitationService`).

**Почему минимально:** покрывает задачу «узнать ближайший статус» без добавления сложного меню клуб→ночь→стол.

### Fallback C: Задать вопрос клубу

**UX-команда:** `/ask`.

**Минимальная реализация:**
1. Команда переводит в простой stateful-диалог из 2 шагов: выбрать клуб (кнопками) → ввести текст вопроса.
2. Бот создаёт тикет через `SupportService.createTicket(...)` напрямую (внутренний сервисный вызов, не HTTP `/api/support`).
3. Отправляет подтверждение с `ticketId` и статусом.

**Почему минимально:** обходит miniapp-auth слой API и использует уже существующую доменную модель поддержки.

## 5) Где miniapp «ломает» достижение цели прямо сейчас

Критические точки разрыва:
1. Webhook-router не подключает guest menu handlers (нет entrypoint для `/my`, `/qr`, `/ask`).
2. Критичные guest-endpoints (`/api/me/bookings`, `/api/bookings/{id}/qr`, `/api/support/*`) требуют miniapp initData.
3. Даже потенциальное подключение `Keyboards.startMenu` сейчас оставит «битые» кнопки (`menu:ask`, `menu:music`) без обработки.

## 6) Рекомендуемый минимальный порядок внедрения

1. Подключить единый `TelegramGuestRouter` в webhook и включить команды `/my`, `/qr`, `/ask` (без восстановления всех legacy callback-веток).
2. Реализовать fallback `/my` и `/qr` через доменный слой бронирований (`BookingState` + `QrBookingCodec`).
3. Реализовать `/ask` через `SupportService` (диалог + create ticket).
4. После этого уже решать, нужен ли реанимированный inline menu flow (`menu:*`) или достаточно командного UX.

Итог: с этими тремя fallback-командами пользователь достигает всех целевых сценариев без miniapp, а риск/объём изменений остаётся минимальным.
