# P2.4 Discovery: деградация без miniapp (user + ops)

## Почему финальная документация остаётся в этом файле

Расширяем `docs/p2.4-discovery-bot-fallbacks.md`, а не создаём второй документ:
- здесь уже зафиксированы discovery-наблюдения и границы fallback-сценариев;
- рядом удобно держать и «почему», и «как работает сейчас»;
- снижаем риск расхождения между discovery и фактическим поведением команд.

## 1) Что подключено в production webhook сейчас

По `Application.kt` в router подключены три ветки Telegram-обработки:
- `InvitationTelegramHandler`;
- `SupportTelegramHandler` (rating callback);
- `TelegramGuestFallbackHandler` (командный fallback без miniapp).

`TelegramCallbackRouter` маршрутизирует:
- callback `support_rate:*` → support;
- callback `inv_confirm:*` / `inv_decline:*` → invitation;
- callback `ask:club:*` и апдейты без callback → guest fallback (с fallback на invitation, если команда не обработана).

## 2) Пользовательский UX без miniapp

Ниже — минимальный командный интерфейс, который позволяет дойти до 3 целевых задач без miniapp.

### 2.1 Доступные команды и алиасы

- `/qr`, алиас `/my_pass` — выдать payload пропуска по ближайшей активной брони.
- `/my`, алиас `/next_booking` — показать ближайшую активную бронь.
- `/invites` — подсказка, как принимать приглашения (через deep-link `/start inv_<token>`).
- `/ask`, алиас `/ask_club` — начать диалог «задать вопрос клубу» (ForceReply flow).
- `/cancel` — отменить текущий `/ask`-flow (только в личном чате).

### 2.2 Что возвращают команды

- `/qr`:
  - при успехе: текстовый payload (`QrBookingCodec`) и короткая инструкция показать код на входе;
  - если брони нет: «Активной брони нет…»;
  - если пользователь не распознан: подсказка `/start` / открыть miniapp.
- `/my`:
  - при успехе: клуб, дата/окно прибытия, стол, статус, подсказка по инвайтам;
  - если брони нет: «Ближайших активных броней нет.»
- `/invites`:
  - всегда информационный ответ, что инвайты принимаются через `/start inv_<token>`.
- `/ask`:
  - если есть активная бронь: сразу ForceReply с выбранным клубом;
  - если брони нет: выбор клуба inline-кнопками, потом ForceReply;
  - после текста вопроса: «Вопрос отправлен…» или «Не удалось отправить…».
- `/cancel`:
  - подтверждение отмены сценария `/ask` в личке;
  - вне лички команда не обрабатывается.

### 2.3 Что делать пользователю в типовых ошибках

- «Нет брони» (`/qr`, `/my`): оформить бронь в miniapp и повторить команду.
- «Нужна авторизация / не зарегистрированы»: написать `/start` в боте, при необходимости открыть miniapp для первичной привязки.
- «Клуб не найден / не удалось определить клуб» в `/ask`: перезапустить flow через `/ask` и выбрать клуб заново.

### 2.4 Примеры диалогов (chat transcript)

#### Диалог 1: `/my` и `/qr`

```text
User: /my
Bot: Ближайшая бронь
     Клуб: Aurora
     Дата: 22.11.2026 21:30
     Окно прибытия: 22.11.2026 21:30 — 22.11.2026 23:00
     Стол: #14
     Статус: BOOKED
     Инвайты: переходите по ссылке вида /start inv_<token>

User: /qr
Bot: Ваш пропуск:
     <payload>

     Покажите этот код на входе.
```

#### Диалог 2: `/ask` + отмена

```text
User: /ask
Bot: Выберите клуб, куда хотите отправить вопрос.
     [кнопки клубов]

User taps inline button "Aurora"
Bot: Вы выбрали Aurora. Ответьте на это сообщение вопросом. clubId:12

User: До какого времени действует депозит?
Bot: Вопрос отправлен в клуб. Мы скоро ответим.

User: /cancel
Bot: Ок, отменено. Когда будете готовы, используйте /ask.
```

## 3) Технические детали для ops/dev

### 3.1 Источники данных и доменный слой

- Брони для `/my` и `/qr`:
  - `BookingState.findUserBookings(userId)`;
  - фильтр по `BookingStatus.BOOKED`;
  - исключение истёкших окон (`arrivalWindow.second >= now`);
  - выбор ближайшей брони по `arrivalWindow.first`, затем `id`.
- QR payload:
  - `QrBookingCodec.encode(bookingId, eventId, updatedAt, QR_SECRET)`.
- Разрешение пользователя:
  - `UserRepository.getByTelegramId(from.id)`.
- `/ask`:
  - выбор клуба через `ClubsRepository`;
  - создание тикета через `SupportService.createTicket(...)`.

### 3.2 Ограничения безопасности

- Команды fallback обрабатываются только в личном чате (`ChatType=Private`), иначе игнор/короткая подсказка.
- Не добавлять логирование текстов вопросов, QR payload и других потенциально чувствительных данных (PII/секреты).
- QR зависит от `QR_SECRET`; при пустом/некорректном секрете команда должна завершаться безопасной ошибкой без утечки деталей.

### 3.3 Ограничения UX

- Flow `/ask` основан на `ForceReply`, без полноценного меню и без «многошагового мастера».
- Нет каталога инвайтов в боте: `/invites` — только discoverability и инструкция по deep-link.
- Это не восстановление legacy `menu:*` флоу.

### 3.4 Что не является целью

- Не реанимируем старое inline-меню (`menu:clubs`, `menu:bookings`, и т.д.).
- Не переносим miniapp-функции 1-в-1 в Telegram-бот.
- Не строим отдельный state-machine движок сверх минимального command + ForceReply сценария.

## 4) Ограничения и edge cases (явный список)

- **Отсутствует user record** (`telegram_user_id` не привязан):
  - команды `/qr`, `/my`, `/ask` не выполняются, бот отправляет подсказку `/start` + miniapp.
- **Несколько броней**:
  - выбирается ближайшая активная (детерминированная сортировка по времени начала и `id`).
- **Истёкшая бронь**:
  - исключается из выборки; для пользователя выглядит как «активной брони нет».
- **Group chats / supergroups / channels**:
  - fallback-команды не обслуживаются как полноценный сценарий, чтобы не светить персональные данные в общих чатах.
- **Invites без листинга**:
  - если листинг инвайтов недоступен, `/invites` возвращает только инструкцию по `/start inv_<token>`.

## 5) Как тестировать

### 5.1 Автотесты / проверки в репозитории

Минимум перед релизом:
- `./gradlew test`
- (при наличии таргетных тестов telegram-пакета) `./gradlew :app-bot:test --tests "*Telegram*"`

### 5.2 Ручная проверка в Telegram

В личном чате с ботом проверить:
1. `/my` для пользователя без брони и с бронью.
2. `/qr` для пользователя без брони, с бронью и при пустом `QR_SECRET`.
3. `/ask` → выбор клуба → ответ в ForceReply → успешное создание тикета.
4. `/ask` → `/cancel`.
5. `/invites` (должна быть инструкция по deep-link).
6. Те же команды в group chat (не должно быть утечки персонального контента).

## 6) Rollout / risk

### 6.1 Минимальный rollout

1. Деплой в staging и ручной smoke по чек-листу выше.
2. Короткий canary в production (ограниченное окно наблюдения).
3. Полный rollout при стабильной телеметрии.

### 6.2 Что мониторить

- Ошибки в telegram webhook-обработке (исключения/failed updates).
- Частоту использования `/ask` и долю `SupportService.createTicket` failure.
- Долю неуспехов `/qr` (нет брони, нет user record, пустой `QR_SECRET`).
- Жалобы на UX (прерывание ForceReply-flow, непонятность `/invites`).

### 6.3 Откат

- Если есть feature-flag маршрутизации fallback-команд — выключить его первым шагом.
- Если feature-flag нет — откат через revert PR и redeploy.
