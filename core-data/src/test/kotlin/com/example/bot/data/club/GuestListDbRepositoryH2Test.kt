package com.example.bot.data.club

import com.example.bot.club.GuestListOwnerType
import com.example.bot.club.GuestListStatus
import com.example.bot.data.booking.EventsTable
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource
import kotlinx.coroutines.runBlocking
import org.flywaydb.core.Flyway
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.Table
import org.jetbrains.exposed.sql.SchemaUtils
import org.jetbrains.exposed.sql.insert
import org.jetbrains.exposed.sql.transactions.transaction
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.time.Clock
import java.time.Instant
import java.time.ZoneOffset

class GuestListDbRepositoryH2Test {
    private lateinit var dataSource: HikariDataSource
    private lateinit var database: Database

    private val fixedInstant: Instant = Instant.parse("2024-05-05T12:00:00Z")
    private val fixedClock: Clock = Clock.fixed(fixedInstant, ZoneOffset.UTC)

    @BeforeEach
    fun setUp() {
        dataSource =
            HikariDataSource(
                HikariConfig().apply {
                    jdbcUrl = "jdbc:h2:mem:guest-list-db;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false"
                    driverClassName = "org.h2.Driver"
                    maximumPoolSize = 2
                },
            )

        val flywayBase =
            Flyway
                .configure()
                .dataSource(dataSource)
                .locations("classpath:db/migration/common", "classpath:db/migration/h2")
                .cleanDisabled(false)
                .target("10")
                .load()

        flywayBase.clean()
        flywayBase.migrate()

        database = Database.connect(dataSource)

        transaction(database) {
            fun recordMigration(
                version: String,
                description: String,
                script: String,
                rank: Int,
            ) {
                val alreadyInserted =
                    exec("SELECT 1 FROM flyway_schema_history WHERE version = '$version'") { rs ->
                        rs.next()
                    } ?: false

                if (!alreadyInserted) {
                    exec(
                        """
                        INSERT INTO flyway_schema_history (
                            installed_rank, version, description, type, script, checksum, installed_by, installed_on, execution_time, success
                        ) VALUES ($rank, '$version', '$description', 'SQL', '$script', NULL, 'test', CURRENT_TIMESTAMP, 0, TRUE)
                        """.trimIndent(),
                    )
                }
            }

            exec(
                """
                CREATE TABLE IF NOT EXISTS suspicious_ips (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    ip VARCHAR(255) NOT NULL,
                    user_agent CLOB,
                    reason VARCHAR(128) NOT NULL,
                    details CLOB,
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
                )
                """.trimIndent(),
            )

            exec(
                """
                CREATE TABLE IF NOT EXISTS promo_links (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    promoter_user_id BIGINT NOT NULL REFERENCES users(id),
                    club_id BIGINT REFERENCES clubs(id),
                    utm_source VARCHAR(255) NOT NULL,
                    utm_medium VARCHAR(255) NOT NULL,
                    utm_campaign VARCHAR(255) NOT NULL,
                    utm_content VARCHAR(255),
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
                )
                """.trimIndent(),
            )
            exec(
                """
                CREATE INDEX IF NOT EXISTS idx_promo_links_promoter_club ON promo_links (promoter_user_id, club_id)
                """.trimIndent(),
            )
            exec(
                """
                CREATE TABLE IF NOT EXISTS promo_attribution (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    booking_id UUID NOT NULL REFERENCES bookings(id) ON DELETE CASCADE,
                    promo_link_id BIGINT NOT NULL REFERENCES promo_links(id) ON DELETE CASCADE,
                    promoter_user_id BIGINT NOT NULL REFERENCES users(id),
                    utm_source VARCHAR(255) NOT NULL,
                    utm_medium VARCHAR(255) NOT NULL,
                    utm_campaign VARCHAR(255) NOT NULL,
                    utm_content VARCHAR(255),
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL,
                    CONSTRAINT uq_promo_attribution_booking UNIQUE (booking_id)
                )
                """.trimIndent(),
            )
            exec("CREATE INDEX IF NOT EXISTS idx_promo_attribution_booking ON promo_attribution (booking_id)")

            exec(
                """
                CREATE TABLE IF NOT EXISTS booking_templates (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    promoter_user_id BIGINT NOT NULL REFERENCES users(id),
                    club_id BIGINT NOT NULL REFERENCES clubs(id),
                    table_capacity_min INTEGER NOT NULL,
                    notes CLOB,
                    is_active BOOLEAN NOT NULL DEFAULT TRUE,
                    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP NOT NULL
                )
                """.trimIndent(),
            )
            exec(
                """
                CREATE INDEX IF NOT EXISTS idx_booking_templates_owner ON booking_templates (promoter_user_id, club_id, is_active)
                """.trimIndent(),
            )

            exec(
                """
                CREATE TABLE IF NOT EXISTS payment_actions (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    booking_id UUID NOT NULL,
                    idempotency_key TEXT NOT NULL,
                    action TEXT NOT NULL,
                    status TEXT NOT NULL,
                    reason TEXT,
                    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                    CONSTRAINT fk_payment_actions_booking FOREIGN KEY (booking_id) REFERENCES bookings(id)
                )
                """.trimIndent(),
            )
            exec(
                """
                CREATE UNIQUE INDEX IF NOT EXISTS payment_actions_idempotency_key_idx ON payment_actions (idempotency_key)
                """.trimIndent(),
            )
            exec(
                """
                CREATE INDEX IF NOT EXISTS payment_actions_booking_idx ON payment_actions (booking_id)
                """.trimIndent(),
            )

            exec(
                """
                CREATE TABLE IF NOT EXISTS layout_tables (
                    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    club_id BIGINT NOT NULL,
                    label VARCHAR(255) NOT NULL,
                    zone_id VARCHAR(64) NOT NULL,
                    minimum_tier VARCHAR(64) NOT NULL,
                    min_deposit BIGINT NOT NULL DEFAULT 0,
                    capacity INT NOT NULL DEFAULT 0,
                    zone VARCHAR(64),
                    arrival_window VARCHAR(32),
                    mystery_eligible BOOLEAN NOT NULL DEFAULT FALSE
                )
                """.trimIndent(),
            )

            SchemaUtils.createMissingTablesAndColumns(
                GuestListsTable,
                GuestListEntriesTable,
                InvitationsTable,
                CheckinsTable,
            )

            exec(
                """
                ALTER TABLE guest_list_entries DROP CONSTRAINT IF EXISTS guest_list_entries_status_check;
                ALTER TABLE guest_list_entries DROP CONSTRAINT IF EXISTS chk_guest_list_entries_status;
                ALTER TABLE guest_list_entries ADD CONSTRAINT guest_list_entries_status_check CHECK (
                    status IN (
                        'ADDED', 'INVITED', 'CONFIRMED', 'DECLINED', 'ARRIVED', 'LATE', 'DENIED',
                        'PLANNED', 'CHECKED_IN', 'NO_SHOW', 'WAITLISTED', 'CALLED', 'EXPIRED'
                    )
                )
                """.trimIndent(),
            )

            recordMigration("11", "webhook security", "V11__webhook_security.sql", rank = 11)
            recordMigration("12", "promo schema", "V12__promo_schema.sql", rank = 12)
            recordMigration("13", "payments actions", "V13__payments_actions.sql", rank = 13)
            recordMigration("16", "admin tables", "V016__admin_tables.sql", rank = 16)
            recordMigration("15", "music track of night", "V015__music_track_of_night.sql", rank = 15)
            recordMigration("17", "guest list invites checkins", "V017__guest_list_invites_checkins.sql", rank = 17)
            recordMigration("18", "guest list schema polish", "V018__guest_list_schema_polish.sql", rank = 18)
        }

        Flyway
            .configure()
            .dataSource(dataSource)
            .locations("classpath:db/migration/common", "classpath:db/migration/h2")
            .cleanDisabled(false)
            .outOfOrder(true)
            .load()
            .migrate()
    }

    @AfterEach
    fun tearDown() {
        dataSource.close()
    }

    @Test
    fun `insertMany returns stable entries`() =
        runBlocking {
            val ownerId = insertUser(username = "owner", displayName = "Owner")
            val clubId = insertClub(name = "Nebula")
            val eventId =
                insertEvent(
                    clubId = clubId,
                    title = "Opening",
                    startAt = fixedInstant,
                    endAt = fixedInstant.plusSeconds(3600),
                )

            val guestListRepo = GuestListDbRepository(database, fixedClock)
            val entryRepo = GuestListEntryDbRepository(database, fixedClock)

            val guestList =
                guestListRepo.create(
                    NewGuestList(
                        clubId = clubId,
                        eventId = eventId,
                        promoterId = ownerId,
                        ownerType = GuestListOwnerType.PROMOTER,
                        ownerUserId = ownerId,
                        title = "VIP",
                        capacity = 10,
                        arrivalWindowStart = fixedInstant,
                        arrivalWindowEnd = fixedInstant.plusSeconds(1800),
                        status = GuestListStatus.ACTIVE,
                    ),
                )

            val entries =
                entryRepo.insertMany(
                    guestList.id,
                    listOf(
                        NewGuestListEntry(displayName = "Alice", telegramUserId = null),
                        NewGuestListEntry(displayName = "Bob", telegramUserId = null),
                        NewGuestListEntry(displayName = "Charlie", telegramUserId = null),
                    ),
                )

            assertEquals(3, entries.size)
            assertEquals(3, entries.count { it.id > 0 })

            val first = entries.first()
            assertEquals(first, entryRepo.findById(first.id))

            val byList = entryRepo.listByGuestList(guestList.id)
            assertEquals(entries.toSet(), byList.toSet())
            assertNotNull(guestList)
        }

    private fun insertClub(
        name: String,
        timezone: String = "Europe/Moscow",
    ): Long =
        transaction(database) {
            TestClubsTable
                .insert {
                    it[TestClubsTable.name] = name
                    it[TestClubsTable.description] = null
                    it[TestClubsTable.timezone] = timezone
                    it[TestClubsTable.adminChannelId] = null
                    it[TestClubsTable.bookingsTopicId] = null
                    it[TestClubsTable.checkinTopicId] = null
                    it[TestClubsTable.qaTopicId] = null
                } get TestClubsTable.id
        }

    private fun insertEvent(
        clubId: Long,
        title: String,
        startAt: Instant,
        endAt: Instant,
    ): Long =
        transaction(database) {
            EventsTable
                .insert {
                    it[EventsTable.clubId] = clubId
                    it[EventsTable.title] = title
                    it[EventsTable.startAt] = startAt.atOffset(ZoneOffset.UTC)
                    it[EventsTable.endAt] = endAt.atOffset(ZoneOffset.UTC)
                    it[EventsTable.isSpecial] = false
                    it[EventsTable.posterUrl] = null
                } get EventsTable.id
        }

    private fun insertUser(
        username: String,
        displayName: String,
    ): Long =
        transaction(database) {
            TestUsersTable
                .insert {
                    it[TestUsersTable.telegramUserId] = null
                    it[TestUsersTable.username] = username
                    it[TestUsersTable.displayName] = displayName
                    it[TestUsersTable.phoneE164] = null
                } get TestUsersTable.id
        }
}

private object TestClubsTable : Table("clubs") {
    val id = long("id").autoIncrement()
    val name = text("name")
    val description = text("description").nullable()
    val timezone = text("timezone")
    val adminChannelId = long("admin_channel_id").nullable()
    val bookingsTopicId = integer("bookings_topic_id").nullable()
    val checkinTopicId = integer("checkin_topic_id").nullable()
    val qaTopicId = integer("qa_topic_id").nullable()
    override val primaryKey = PrimaryKey(id)
}

private object TestUsersTable : Table("users") {
    val id = long("id").autoIncrement()
    val telegramUserId = long("telegram_user_id").nullable()
    val username = text("username").nullable()
    val displayName = text("display_name").nullable()
    val phoneE164 = text("phone_e164").nullable()
    override val primaryKey = PrimaryKey(id)
}
